<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cryptography on Poney Island</title><link>https://0xade1.github.io/categories/cryptography/</link><description>Recent content in cryptography on Poney Island</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 16 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://0xade1.github.io/categories/cryptography/index.xml" rel="self" type="application/rss+xml"/><item><title>picoCTF 2021 - Cryptography</title><link>https://0xade1.github.io/posts/2021/08/picoctf-2021-cryptography/</link><pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate><guid>https://0xade1.github.io/posts/2021/08/picoctf-2021-cryptography/</guid><description>Mod 26 echo &amp;#34;cvpbPGS{arkg_gvzr_V&amp;#39;yy_gel_2_ebhaqf_bs_ebg13_hyLicInt}&amp;#34; | tr &amp;#39;[n-za-m]&amp;#39; &amp;#39;[a-z]&amp;#39; | tr &amp;#39;[N-ZA-M]&amp;#39; &amp;#39;[A-Z]&amp;#39; Mind your Ps and Qs Decrypt my super sick RSA: c: 861270243527190895777142537838333832920579264010533029282104230006461420086153423 n: 1311097532562595991877980619849724606784164430105441327897358800116889057763413423 e: 65537 if n is small then it can be factorized on factordb.com
FactorDB is also available in python with pip3 install factordb-pycli:
from factordb.factordb import FactorDB n = 1311097532562595991877980619849724606784164430105441327897358800116889057763413423 f = FactorDB(n) f.connect() p, q = f.get_factor_list() Once factorized, we can calculate the totient ph and perform some arithmetic with an optimized C-coded python library pip3 install gmpy2</description></item><item><title>picoCTF 2018 - Cryptography</title><link>https://0xade1.github.io/posts/2019/12/picoctf-2018-cryptography/</link><pubDate>Thu, 19 Dec 2019 00:54:12 +0800</pubDate><guid>https://0xade1.github.io/posts/2019/12/picoctf-2018-cryptography/</guid><description>Crypto-warmup-1 The fastest way is pip install pycipher
pip install pycipher python2 &amp;gt;&amp;gt;&amp;gt; c = &amp;#39;llkjmlmpadkkc&amp;#39;.upper() &amp;gt;&amp;gt;&amp;gt; k = &amp;#39;thisisalilkey&amp;#39;.upper() &amp;gt;&amp;gt;&amp;gt; from pycipher import Vigenere &amp;gt;&amp;gt;&amp;gt; plaintext = Vigenere(k).decipher(c) &amp;gt;&amp;gt;&amp;gt; print plaintext SECRETMESSAGE We can also code ourselves but it takes a bit more time ;)
#!/usr/bin/env python c = &amp;#39;llkjmlmpadkkc&amp;#39;.upper() k = &amp;#39;thisisalilkey&amp;#39;.upper() alphabet = &amp;#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#39; def ror(message, cnt): message = message[cnt:]+message[0:cnt] return message def rotate(letter): i = alphabet.find(letter) r = ror(alphabet, i) return r def offset(rotated_alphabet, letter): i = alphabet.</description></item></channel></rss>