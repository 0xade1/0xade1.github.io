<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ELF on Poney Island</title>
    <link>https://0xade1.github.io/devdraft/tags/elf/</link>
    <description>Recent content in ELF on Poney Island</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 19 Dec 2019 00:54:12 +0800</lastBuildDate><atom:link href="https://0xade1.github.io/devdraft/tags/elf/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>picoCTF 2018 - Binary Exploitation</title>
      <link>https://0xade1.github.io/devdraft/posts/2019/12/picoctf-2018-binary-exploitation/</link>
      <pubDate>Thu, 19 Dec 2019 00:54:12 +0800</pubDate>
      
      <guid>https://0xade1.github.io/devdraft/posts/2019/12/picoctf-2018-binary-exploitation/</guid>
      <description>buffer-overflow-0 source: vuln.c binary: vuln The below code is vulnerable to bufferoverflow as input can be bigger then the 16 bytes buffer size
void vuln(char *input){ char buf[16]; strcpy(buf, input); } ./vuln XXXXXXXXXXXXXXXXXXXX
buffer-overflow-1 source: vuln.c binary: vuln The below code is vulnerable to overflow attack because gets cannot know in advance whether the size of the user input will be bigger then BUFSIZE
void vuln(){ char buf[BUFSIZE]; gets(buf); } With radare2, we can deduct the size of the overflow without dumping a core:</description>
    </item>
    
    <item>
      <title>picoCTF 2018 - Reverse Engineering</title>
      <link>https://0xade1.github.io/devdraft/posts/2019/12/picoctf-2018-reverse-engineering/</link>
      <pubDate>Thu, 19 Dec 2019 00:54:12 +0800</pubDate>
      
      <guid>https://0xade1.github.io/devdraft/posts/2019/12/picoctf-2018-reverse-engineering/</guid>
      <description>Recommended resources: Assembler tutorial Register Calling conventions common-x86-calling-conventions X86_Disassembly/Calling_Conventions Wikipedia x86_64 calling convention assembly-0 The program is called with two arguments: asm0(0xc9, 0xb0), so the stack frame looks like the following: calling convention is cdecl | adress of argument2	|	ebp+12 | adress of argument1	|	ebp+8 | return address	|	ebp+4 | old ebp	| &amp;lt;--- ebp nasm code source:
.intel_syntax noprefix .bits 32 .global asm0 asm0: push	ebp	;prolog mov	ebp,esp	;prolog mov	eax,DWORD PTR [ebp+0x8]	;eax receives 4 bytes pointing to argument1 which is the value 0xc9 mov	ebx,DWORD PTR [ebp+0xc] ;ebx receives 4 bytes pointing to argument2 which is the value 0xb0 mov	eax,ebx	;eax is overwritten by ebx mov	esp,ebp	;epilog pop	ebp	;epilog ret	;epilog mov eax, DWORD PTR [mem]: Get 32-bit value at memory address and store it in eax register: see here</description>
    </item>
    
  </channel>
</rss>
