<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>base64 on Poney Island</title><link>https://0xade1.github.io/tags/base64/</link><description>Recent content in base64 on Poney Island</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 19 Dec 2019 00:54:12 +0800</lastBuildDate><atom:link href="https://0xade1.github.io/tags/base64/index.xml" rel="self" type="application/rss+xml"/><item><title>picoCTF 2018 - Binary Exploitation</title><link>https://0xade1.github.io/posts/2019/12/picoctf-2018-binary-exploitation/</link><pubDate>Thu, 19 Dec 2019 00:54:12 +0800</pubDate><guid>https://0xade1.github.io/posts/2019/12/picoctf-2018-binary-exploitation/</guid><description>buffer-overflow-0 source: vuln.c binary: vuln The below code is vulnerable to bufferoverflow as input can be bigger then the 16 bytes buffer size
void vuln(char *input){ char buf[16]; strcpy(buf, input); } ./vuln XXXXXXXXXXXXXXXXXXXX
buffer-overflow-1 source: vuln.c binary: vuln The below code is vulnerable to overflow attack because gets cannot know in advance whether the size of the user input will be bigger then BUFSIZE
void vuln(){ char buf[BUFSIZE]; gets(buf); } With radare2, we can deduct the size of the overflow without dumping a core:</description></item></channel></rss>